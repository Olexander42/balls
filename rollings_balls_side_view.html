<!DOCTYPE html>
<html>
  <head>
    <title>BALLS</title>
  </head>
  <body style="text-align: center;">
    <canvas width="1700" height="700" style="border: solid 1px gray"></canvas>
    
    <script>
      // some balls still get stuck after collision
      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");

      const ms = 100; 
      const frictionLoss = 0.2 / (1000 / ms); 
      const r = 100;

      let balls = {};
      let numOfBalls;

      let ranges = [[r, canvas.width - r]]; 

      function choice(array) { // randomly choose an element out of any array
        return array[Math.floor(Math.random() * (array.length))];
      }

      function getRandomInt(min, max) { // randomly pick a value from the range (except 0)
        while (true) {
          let result = Math.floor(Math.random() * ((max - min) +1) + min);
          if (result !== 0) return result;
        }
      };      

      class Ball {
        constructor(name, color, x, speed) {
          this.name = name;
          this.color = color;
          this.r = r;
          this.range = choice(ranges)
          this.x = getRandomInt(this.range[0], this.range[1]); 
          this.y = canvas.height - getRandomInt(this.r, canvas.height - this.r); 
          this.xSpeed = getRandomInt(-50, 50);
          this.ySpeed = 0;
          this.g = 1;
          this.moving = true;
          this.updateRanges();
          this._draw();
        }

        move() {
          if (this.moving === true) {
            this.ySpeed += this.g;
            this.x += this.xSpeed;
            this.y += this.ySpeed;
            this._checkBorderCollision();
            this._checkRolling();
            if (Math.abs(this.xSpeed) < 0.1) this.moving = false; 
          } 
          this._draw(); 
        }

        updateRanges() {
          for (let i = 0; i < ranges.length; i++) { // pick one range after another
            let [rangeMin, rangeMax] = ranges[i]
            if (this.x >= rangeMin && this.x <= rangeMax) { // the ball has found the range 
              if (this.x - rangeMin < 2 * r && rangeMax - this.x < 3 * r) { // there's no space on either side anymore
                ranges.splice(i, 1); // delete the range altogether
              } else if (this.x - rangeMin < 2 * r) { // there's no space for another ball on the left
                ranges[i][0] = this.x + 2 * r// cut off that dead zone on the left
              } else if (rangeMax - this.x < 2 * r) { // there's no space for another ball on the right
                ranges[i][1] = this.x - 2 * r // cut off that dead zone on the right 
              } else { // there's enough space for a ball on both sides
                // split the current range into two new ranges 
                let newRangeLeft = [rangeMin, this.x - 2 * this.r]; 
                let newRangeRight = [this.x + 2 * this.r, rangeMax];
                ranges.splice(i, 1, newRangeLeft, newRangeRight); // replace the current range with the two new ranges
              }
              break;
            }
          }
        }

        _draw() {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
          ctx.fill(); 
        };   

        _checkBorderCollision() {
          if ((this.x > canvas.width - this.r && this.xSpeed > 0) || // right border
            (this.x < this.r  && this.xSpeed < 0)) { // left border
            this.x += this.xSpeed;
            this.xSpeed *= -0.5;
          }

          if ((this.y >= canvas.height - this.r && this.ySpeed >= 0) || // bottom border
              (this.y < this.r && this.ySpeed < 0)) { // top border
              this.y += this.ySpeed;
              this.ySpeed *= -0.75;
          } 
        };

        _checkRolling() {
          if (this.y >= canvas.height - this.r && Math.abs(this.ySpeed) <= this.g) { 
            this.g = 0;
            this.ySpeed = 0;
            this.xSpeed *= (1 - frictionLoss); // ball rolls on the ground
          }
        }
      }

      function ballNameGenerator(n) {
        let name = "ball" + n.toString();
        return name;
      }

      function ballGrabber(ballsArr, n) {
        let name = ballNameGenerator(n);  
        let ball = ballsArr[name];
        return ball;
      }

      function checkBallsCollision() {
        for (let n1 = 1; n1 < numOfBalls; n1++) { // evaluate balls positions in pairs (1 - 2, 1 - 3, 2 - 3, and so on)
          let ball1 = ballGrabber(balls, n1)
          for (let n2 = n1 + 1; n2 <= numOfBalls; n2++) { // start right after key1
            let ball2 = ballGrabber(balls, n2);
            if (Math.abs(ball1.x - ball2.x) <= r * 2)  { // balls touch each other
                if (ball1.xSpeed * ball2.xSpeed > 0 && Math.abs(ball1.xSpeed) > Math.abs(ball2.xSpeed)) { // if ball1 and ball2 move in the same direction but ball1 hits ball2
                  ball2.xSpeed += ball1.xSpeed * 0.25; // ball2 adds energy
                  ball1.x -= ball1.xSpeed; // ball1 bounces back
                  ball1.xSpeed *= -0.5; // ball1 loses energy
                  ball2.x += ball2.xSpeed; // ball2 bounces forward
                } else if (ball1.xSpeed * ball2.xSpeed > 0 && Math.abs(ball1.xSpeed) < Math.abs(ball2.xSpeed)) { // if ball1 and ball2 move in the same direction but ball2 hits ball1
                  ball1.xSpeed += ball2.xSpeed * 0.25; // ball2 adds energy
                  ball2.x -= ball2.xSpeed; // ball1 bounces back
                  ball2.xSpeed *= -0.5; // ball1 loses energy
                  ball1.x += ball1.xSpeed; // ball2 bounces forward
                } else {
                  ball1.x -= ball1.xSpeed;
                  ball1.xSpeed *= -0.5;
                  ball2.x -= ball2.xSpeed;
                  ball2.xSpeed *= -0.5;
                }
              }
            };
          };
        };


      function ballsFactory(num) {
        let n = 1;
        let colors = ["black", "red", "blue", "orange", "yellow", "green", "indigo", "violet", "silver"]
        while (num > 0 && ranges.length > 0) { // repeat the cycle as many times as you many balls you want
          let name = ballNameGenerator(n);
          balls[name] = new Ball(name, choice(colors)); // add a new Ball class instance with a new name
          n++;
          num--;
        } 
        numOfBalls = Object.keys(balls).length; // update the number of balls
      }

      ballsFactory(10);
      
      const intervalId = setInterval( () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 1; i <= numOfBalls; i++) {
          let name = "ball" + i.toString();
          balls[name].move();
        }
        checkBallsCollision(); 
      }, ms);        
    </script>
  </body>
</html>